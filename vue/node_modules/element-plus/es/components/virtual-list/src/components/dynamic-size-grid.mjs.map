{"version":3,"file":"dynamic-size-grid.mjs","sources":["../../../../../../../packages/components/virtual-list/src/components/dynamic-size-grid.ts"],"sourcesContent":["import { isFunction } from '@vue/shared'\nimport { throwError } from '@element-plus/utils/error'\nimport createGrid from '../builders/build-grid'\n\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\nimport type { VirtualizedGridProps } from '../props'\n\nimport type { Alignment, GridCache, ListItem, ItemSize } from '../types'\n\nconst { max, min, floor } = Math\nconst SCOPE = 'ElDynamicSizeGrid'\n\ntype Props = VirtualizedGridProps\ntype CacheItemType = 'column' | 'row'\n\n// generates props access key via type\nconst ACCESS_SIZER_KEY_MAP = {\n  column: 'columnWidth',\n  row: 'rowHeight',\n}\n\n// generates cache access key via type\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: 'lastVisitedColumnIndex',\n  row: 'lastVisitedRowIndex',\n}\n\nconst getItemFromCache = (\n  props: Props,\n  index: number,\n  gridCache: GridCache,\n  type: CacheItemType\n) => {\n  const [cachedItems, sizer, lastVisited] = [\n    gridCache[type],\n    props[ACCESS_SIZER_KEY_MAP[type]],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]],\n  ] as [Record<string, ListItem>, ItemSize, number]\n\n  if (index > lastVisited) {\n    let offset = 0\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited]\n      offset = item.offset + item.size\n    }\n\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i)\n\n      cachedItems[i] = {\n        offset,\n        size,\n      }\n\n      offset += size\n    }\n\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index\n  }\n\n  return cachedItems[index]\n}\n\nconst bs = (\n  props: Props,\n  gridCache: GridCache,\n  low: number,\n  high: number,\n  offset: number,\n  type: CacheItemType\n) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2)\n    const currentOffset = getItemFromCache(props, mid, gridCache, type).offset\n\n    if (currentOffset === offset) {\n      return mid\n    } else if (currentOffset < offset) {\n      low = mid + 1\n    } else {\n      high = mid - 1\n    }\n  }\n\n  return max(0, low - 1)\n}\n\nconst es = (\n  props: Props,\n  gridCache: GridCache,\n  idx: number,\n  offset: number,\n  type: CacheItemType\n) => {\n  const total = type === 'column' ? props.totalColumn : props.totalRow\n  let exponent = 1\n\n  while (\n    idx < total &&\n    getItemFromCache(props, idx, gridCache, type).offset < offset\n  ) {\n    idx += exponent\n    exponent *= 2\n  }\n\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type)\n}\n\nconst findItem = (\n  props: Props,\n  gridCache: GridCache,\n  offset: number,\n  type: CacheItemType\n) => {\n  const [cache, lastVisitedIndex] = [\n    gridCache[type],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]],\n  ] as [Record<string, ListItem>, number]\n\n  const lastVisitedItemOffset =\n    lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0\n\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type)\n  }\n\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type)\n}\n\nconst getEstimatedTotalHeight = (\n  { totalRow }: Props,\n  { estimatedRowHeight, lastVisitedRowIndex, row }: GridCache\n) => {\n  let sizeOfVisitedRows = 0\n\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1\n  }\n\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex]\n    sizeOfVisitedRows = item.offset + item.size\n  }\n\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight\n\n  return sizeOfVisitedRows + sizeOfUnvisitedItems\n}\nconst getEstimatedTotalWidth = (\n  { totalColumn }: Props,\n  { column, estimatedColumnWidth, lastVisitedColumnIndex }: GridCache\n) => {\n  let sizeOfVisitedColumns = 0\n\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1\n  }\n\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex]\n    sizeOfVisitedColumns = item.offset + item.size\n  }\n\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth\n\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems\n}\n\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight,\n}\n\nconst getOffset = (\n  props: Props,\n  index: number,\n  alignment: Alignment,\n  scrollOffset: number,\n  cache: GridCache,\n  type: CacheItemType,\n  scrollBarWidth: number\n) => {\n  const [size, estimatedSizeAssociates] = [\n    type === 'row' ? props.height : props.width,\n    ACCESS_ESTIMATED_SIZE_KEY_MAP[type],\n  ] as [number, (props: Props, cache: GridCache) => number]\n  const item = getItemFromCache(props, index, cache, type)\n\n  const estimatedSize = estimatedSizeAssociates(props, cache)\n\n  const maxOffset = max(0, min(estimatedSize - size, item.offset))\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size)\n\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT\n    } else {\n      alignment = CENTERED_ALIGNMENT\n    }\n  }\n\n  switch (alignment) {\n    case START_ALIGNMENT: {\n      return maxOffset\n    }\n    case END_ALIGNMENT: {\n      return minOffset\n    }\n    case CENTERED_ALIGNMENT: {\n      return Math.round(minOffset + (maxOffset - minOffset) / 2)\n    }\n    case AUTO_ALIGNMENT:\n    default: {\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset\n      } else if (minOffset > maxOffset) {\n        return minOffset\n      } else if (scrollOffset < minOffset) {\n        return minOffset\n      } else {\n        return maxOffset\n      }\n    }\n  }\n}\n\nconst FixedSizeGrid = createGrid({\n  name: 'ElDynamicSizeGrid',\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, 'column')\n    return [item.size, item.offset]\n  },\n\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, 'row')\n    return [item.size, item.offset]\n  },\n\n  getColumnOffset: (\n    props,\n    columnIndex,\n    alignment,\n    scrollLeft,\n    cache,\n    scrollBarWidth\n  ) =>\n    getOffset(\n      props,\n      columnIndex,\n      alignment,\n      scrollLeft,\n      cache,\n      'column',\n      scrollBarWidth\n    ),\n\n  getRowOffset: (\n    props,\n    rowIndex,\n    alignment,\n    scrollTop,\n    cache,\n    scrollBarWidth: number\n  ) =>\n    getOffset(\n      props,\n      rowIndex,\n      alignment,\n      scrollTop,\n      cache,\n      'row',\n      scrollBarWidth\n    ),\n\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) =>\n    findItem(props, cache, scrollLeft, 'column'),\n\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache(props, startIndex, cache, 'column')\n\n    const maxOffset = scrollLeft + (props.width as number)\n\n    let offset = item.offset + item.size\n    let stopIndex = startIndex\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, startIndex, cache, 'column').size\n    }\n    return stopIndex\n  },\n\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n\n  getRowStartIndexForOffset: (props, scrollTop, cache) =>\n    findItem(props, cache, scrollTop, 'row'),\n\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const { totalRow, height } = props\n    const item = getItemFromCache(props, startIndex, cache, 'row')\n    const maxOffset = scrollTop + (height as number)\n\n    let offset = item.size + item.offset\n    let stopIndex = startIndex\n\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, stopIndex, cache, 'row').size\n    }\n\n    return stopIndex\n  },\n\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {},\n    } as GridCache\n\n    // TODO: expose methods.\n    return cache\n  },\n\n  clearCache: true,\n\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isFunction(columnWidth)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `\n        )\n      }\n\n      if (!isFunction(rowHeight)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `\n        )\n      }\n    }\n  },\n})\n\nexport default FixedSizeGrid\n"],"names":[],"mappings":"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"}
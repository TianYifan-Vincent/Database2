{"version":3,"file":"dynamic-size-list.mjs","sources":["../../../../../../../packages/components/virtual-list/src/components/dynamic-size-list.ts"],"sourcesContent":["import { throwError } from '@element-plus/utils/error'\n\nimport createList from '../builders/build-list'\n\nimport { isHorizontal } from '../utils'\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\nimport type { VirtualizedListProps } from '../props'\n\nimport type { ListCache, ListItem, ItemSize } from '../types'\n\ntype Props = VirtualizedListProps\n\nconst SCOPE = 'ElDynamicSizeList'\nconst getItemFromCache = (\n  props: Props,\n  index: number,\n  listCache: ListCache\n): ListItem => {\n  const { itemSize } = props\n  const { items, lastVisitedIndex } = listCache\n\n  if (index > lastVisitedIndex) {\n    let offset = 0\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex]\n      offset = item.offset + item.size\n    }\n\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = (itemSize as ItemSize)(i)\n\n      items[i] = {\n        offset,\n        size,\n      }\n\n      offset += size\n    }\n\n    listCache.lastVisitedIndex = index\n  }\n\n  return items[index]\n}\n\nconst findItem = (props: Props, listCache: ListCache, offset: number) => {\n  const { items, lastVisitedIndex } = listCache\n\n  const lastVisitedOffset =\n    lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0\n\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset)\n  }\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset)\n}\n\n// bs stands for binary search which has approximately time complexity of O(Log n)\n// space complexity of O(1)\n// in this case we use it for search the offset of each item, since\n// the cached items' offset is monotonically increasing\nconst bs = (\n  props: Props,\n  listCache: ListCache,\n  low: number,\n  high: number,\n  offset: number\n) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2)\n    const currentOffset = getItemFromCache(props, mid, listCache).offset\n\n    if (currentOffset === offset) {\n      return mid\n    } else if (currentOffset < offset) {\n      low = mid + 1\n    } else if (currentOffset > offset) {\n      high = mid - 1\n    }\n  }\n\n  return Math.max(0, low - 1)\n}\n\n// es stands for exponential search which has time complexity of O(Log n) and\n// space complexity of O(1) in the case of finding the boundary element.\n// the exponential indicator in this case is 2.\n// for more detail about exponential search click this link\n// https://www.freecodecamp.org/news/search-algorithms-exponential-search-explained/\n\nconst es = (\n  props: Props,\n  listCache: ListCache,\n  index: number,\n  offset: number\n) => {\n  const { total } = props\n  let exponent = 1\n\n  while (\n    index < total &&\n    getItemFromCache(props, index, listCache).offset < offset\n  ) {\n    index += exponent\n    exponent *= 2\n  }\n\n  return bs(\n    props,\n    listCache,\n    Math.floor(index / 2),\n    Math.min(index, total - 1),\n    offset\n  )\n}\n\nconst getEstimatedTotalSize = (\n  { total }: Props,\n  { items, estimatedItemSize, lastVisitedIndex }: ListCache\n) => {\n  let totalSizeOfMeasuredItems = 0\n\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1\n  }\n\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex]\n    totalSizeOfMeasuredItems = item.offset + item.size\n  }\n\n  const numUnmeasuredItems = total - lastVisitedIndex - 1\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems\n}\n\nconst DynamicSizeList = createList({\n  name: 'ElDynamicSizeList',\n  getItemOffset: (props, index, listCache) =>\n    getItemFromCache(props, index, listCache).offset,\n\n  getItemSize: (_, index, { items }) => items[index].size,\n\n  getEstimatedTotalSize,\n\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const { height, layout, width } = props\n\n    const size = (isHorizontal(layout) ? width : height) as number\n    const item = getItemFromCache(props, index, listCache)\n\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache)\n\n    const maxOffset = Math.max(\n      0,\n      Math.min(estimatedTotalSize - size, item.offset)\n    )\n    const minOffset = Math.max(0, item.offset - size + item.size)\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        alignment = AUTO_ALIGNMENT\n      } else {\n        alignment = CENTERED_ALIGNMENT\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset\n      }\n      case END_ALIGNMENT: {\n        return minOffset\n      }\n      case CENTERED_ALIGNMENT: {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2)\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset\n        } else if (scrollOffset < minOffset) {\n          return minOffset\n        } else {\n          return maxOffset\n        }\n      }\n    }\n  },\n\n  getStartIndexForOffset: (props, offset, listCache) =>\n    findItem(props, listCache, offset),\n\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const { height, total, layout, width } = props\n\n    const size = (isHorizontal(layout) ? width : height) as number\n    const item = getItemFromCache(props, startIndex, listCache)\n    const maxOffset = scrollOffset + size\n\n    let offset = item.offset + item.size\n    let stopIndex = startIndex\n\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, stopIndex, listCache).size\n    }\n\n    return stopIndex\n  },\n\n  initCache({ estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1,\n    } as ListCache\n\n    cache.clearCacheAfterIndex = (index: number, forceUpdate = true) => {\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1)\n      instance.exposed?.getItemStyleCache(-1)\n\n      if (forceUpdate) {\n        instance.proxy?.$forceUpdate()\n      }\n    }\n\n    return cache\n  },\n\n  clearCache: false,\n\n  validateProps: ({ itemSize }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throwError(\n          SCOPE,\n          `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `\n        )\n      }\n    }\n  },\n})\n\nexport default DynamicSizeList\n"],"names":[],"mappings":"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"}
{"version":3,"file":"tree-store.mjs","sources":["../../../../../../../packages/components/tree/src/model/tree-store.ts"],"sourcesContent":["import { hasOwn } from '@vue/shared'\nimport Node from './node'\nimport { getNodeKey } from './util'\n\nimport type {\n  TreeKey,\n  TreeData,\n  TreeStoreNodesMap,\n  LoadFunction,\n  FilterNodeMethodFunction,\n  TreeOptionProps,\n  TreeStoreOptions,\n  FilterValue,\n  TreeNodeData,\n} from '../tree.type'\n\nexport default class TreeStore {\n  currentNode: Node\n  currentNodeKey: TreeKey\n  nodesMap: TreeStoreNodesMap\n  root: Node\n  data: TreeData\n  lazy: boolean\n  load: LoadFunction\n  filterNodeMethod: FilterNodeMethodFunction\n  key: TreeKey\n  defaultCheckedKeys: TreeKey[]\n  checkStrictly: boolean\n  defaultExpandedKeys: TreeKey[]\n  autoExpandParent: boolean\n  defaultExpandAll: boolean\n  checkDescendants: boolean\n  props: TreeOptionProps\n\n  constructor(options: TreeStoreOptions) {\n    this.currentNode = null\n    this.currentNodeKey = null\n\n    for (const option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option]\n      }\n    }\n\n    this.nodesMap = {}\n  }\n\n  initialize() {\n    this.root = new Node({\n      data: this.data,\n      store: this,\n    })\n    this.root.initialize()\n\n    if (this.lazy && this.load) {\n      const loadFn = this.load\n      loadFn(this.root, (data) => {\n        this.root.doCreateChildren(data)\n        this._initDefaultCheckedNodes()\n      })\n    } else {\n      this._initDefaultCheckedNodes()\n    }\n  }\n\n  filter(value: FilterValue): void {\n    const filterNodeMethod = this.filterNodeMethod\n    const lazy = this.lazy\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        child.visible = filterNodeMethod.call(child, value, child.data, child)\n\n        traverse(child)\n      })\n\n      if (!(node as Node).visible && childNodes.length) {\n        let allHidden = true\n        allHidden = !childNodes.some((child) => child.visible)\n\n        if ((node as TreeStore).root) {\n          ;(node as TreeStore).root.visible = allHidden === false\n        } else {\n          ;(node as Node).visible = allHidden === false\n        }\n      }\n      if (!value) return\n\n      if ((node as Node).visible && !(node as Node).isLeaf && !lazy)\n        (node as Node).expand()\n    }\n\n    traverse(this)\n  }\n\n  setData(newVal: TreeData): void {\n    const instanceChanged = newVal !== this.root.data\n    if (instanceChanged) {\n      this.root.setData(newVal)\n      this._initDefaultCheckedNodes()\n    } else {\n      this.root.updateChildren()\n    }\n  }\n\n  getNode(data: TreeKey | TreeNodeData): Node {\n    if (data instanceof Node) return data\n    const key = typeof data !== 'object' ? data : getNodeKey(this.key, data)\n    return this.nodesMap[key] || null\n  }\n\n  insertBefore(data: TreeNodeData, refData: TreeKey | TreeNodeData): void {\n    const refNode = this.getNode(refData)\n    refNode.parent.insertBefore({ data }, refNode)\n  }\n\n  insertAfter(data: TreeNodeData, refData: TreeKey | TreeNodeData): void {\n    const refNode = this.getNode(refData)\n    refNode.parent.insertAfter({ data }, refNode)\n  }\n\n  remove(data: TreeNodeData | Node): void {\n    const node = this.getNode(data)\n\n    if (node && node.parent) {\n      if (node === this.currentNode) {\n        this.currentNode = null\n      }\n      node.parent.removeChild(node)\n    }\n  }\n\n  append(data: TreeNodeData, parentData: TreeNodeData | TreeKey | Node): void {\n    const parentNode = parentData ? this.getNode(parentData) : this.root\n\n    if (parentNode) {\n      parentNode.insertChild({ data })\n    }\n  }\n\n  _initDefaultCheckedNodes(): void {\n    const defaultCheckedKeys = this.defaultCheckedKeys || []\n    const nodesMap = this.nodesMap\n\n    defaultCheckedKeys.forEach((checkedKey) => {\n      const node = nodesMap[checkedKey]\n\n      if (node) {\n        node.setChecked(true, !this.checkStrictly)\n      }\n    })\n  }\n\n  _initDefaultCheckedNode(node: Node): void {\n    const defaultCheckedKeys = this.defaultCheckedKeys || []\n\n    if (defaultCheckedKeys.indexOf(node.key) !== -1) {\n      node.setChecked(true, !this.checkStrictly)\n    }\n  }\n\n  setDefaultCheckedKey(newVal: TreeKey[]): void {\n    if (newVal !== this.defaultCheckedKeys) {\n      this.defaultCheckedKeys = newVal\n      this._initDefaultCheckedNodes()\n    }\n  }\n\n  registerNode(node: Node): void {\n    const key = this.key\n    if (!node || !node.data) return\n\n    if (!key) {\n      this.nodesMap[node.id] = node\n    } else {\n      const nodeKey = node.key\n      if (nodeKey !== undefined) this.nodesMap[node.key] = node\n    }\n  }\n\n  deregisterNode(node: Node): void {\n    const key = this.key\n    if (!key || !node || !node.data) return\n\n    node.childNodes.forEach((child) => {\n      this.deregisterNode(child)\n    })\n\n    delete this.nodesMap[node.key]\n  }\n\n  getCheckedNodes(\n    leafOnly = false,\n    includeHalfChecked = false\n  ): TreeNodeData[] {\n    const checkedNodes: TreeNodeData[] = []\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        if (\n          (child.checked || (includeHalfChecked && child.indeterminate)) &&\n          (!leafOnly || (leafOnly && child.isLeaf))\n        ) {\n          checkedNodes.push(child.data)\n        }\n\n        traverse(child)\n      })\n    }\n\n    traverse(this)\n\n    return checkedNodes\n  }\n\n  getCheckedKeys(leafOnly = false): TreeKey[] {\n    return this.getCheckedNodes(leafOnly).map((data) => (data || {})[this.key])\n  }\n\n  getHalfCheckedNodes(): TreeNodeData[] {\n    const nodes: TreeNodeData[] = []\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        if (child.indeterminate) {\n          nodes.push(child.data)\n        }\n\n        traverse(child)\n      })\n    }\n\n    traverse(this)\n\n    return nodes\n  }\n\n  getHalfCheckedKeys(): TreeKey[] {\n    return this.getHalfCheckedNodes().map((data) => (data || {})[this.key])\n  }\n\n  _getAllNodes(): Node[] {\n    const allNodes: Node[] = []\n    const nodesMap = this.nodesMap\n    for (const nodeKey in nodesMap) {\n      if (hasOwn(nodesMap, nodeKey)) {\n        allNodes.push(nodesMap[nodeKey])\n      }\n    }\n\n    return allNodes\n  }\n\n  updateChildren(key: TreeKey, data: TreeData): void {\n    const node = this.nodesMap[key]\n    if (!node) return\n    const childNodes = node.childNodes\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      const child = childNodes[i]\n      this.remove(child.data)\n    }\n    for (let i = 0, j = data.length; i < j; i++) {\n      const child = data[i]\n      this.append(child, node.data)\n    }\n  }\n\n  _setCheckedKeys(\n    key: TreeKey,\n    leafOnly = false,\n    checkedKeys: { [key: string]: boolean }\n  ): void {\n    const allNodes = this._getAllNodes().sort((a, b) => b.level - a.level)\n    const cache = Object.create(null)\n    const keys = Object.keys(checkedKeys)\n    allNodes.forEach((node) => node.setChecked(false, false))\n    for (let i = 0, j = allNodes.length; i < j; i++) {\n      const node = allNodes[i]\n      const nodeKey = node.data[key].toString()\n      const checked = keys.indexOf(nodeKey) > -1\n      if (!checked) {\n        if (node.checked && !cache[nodeKey]) {\n          node.setChecked(false, false)\n        }\n        continue\n      }\n\n      let parent = node.parent\n      while (parent && parent.level > 0) {\n        cache[parent.data[key]] = true\n        parent = parent.parent\n      }\n\n      if (node.isLeaf || this.checkStrictly) {\n        node.setChecked(true, false)\n        continue\n      }\n      node.setChecked(true, true)\n\n      if (leafOnly) {\n        node.setChecked(false, false)\n        const traverse = function (node: Node): void {\n          const childNodes = node.childNodes\n          childNodes.forEach((child) => {\n            if (!child.isLeaf) {\n              child.setChecked(false, false)\n            }\n            traverse(child)\n          })\n        }\n        traverse(node)\n      }\n    }\n  }\n\n  setCheckedNodes(array: Node[], leafOnly = false): void {\n    const key = this.key\n    const checkedKeys = {}\n    array.forEach((item) => {\n      checkedKeys[(item || {})[key]] = true\n    })\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys)\n  }\n\n  setCheckedKeys(keys: TreeKey[], leafOnly = false): void {\n    this.defaultCheckedKeys = keys\n    const key = this.key\n    const checkedKeys = {}\n    keys.forEach((key) => {\n      checkedKeys[key] = true\n    })\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys)\n  }\n\n  setDefaultExpandedKeys(keys: TreeKey[]) {\n    keys = keys || []\n    this.defaultExpandedKeys = keys\n    keys.forEach((key) => {\n      const node = this.getNode(key)\n      if (node) node.expand(null, this.autoExpandParent)\n    })\n  }\n\n  setChecked(\n    data: TreeKey | TreeNodeData,\n    checked: boolean,\n    deep: boolean\n  ): void {\n    const node = this.getNode(data)\n\n    if (node) {\n      node.setChecked(!!checked, deep)\n    }\n  }\n\n  getCurrentNode(): Node {\n    return this.currentNode\n  }\n\n  setCurrentNode(currentNode: Node): void {\n    const prevCurrentNode = this.currentNode\n    if (prevCurrentNode) {\n      prevCurrentNode.isCurrent = false\n    }\n    this.currentNode = currentNode\n    this.currentNode.isCurrent = true\n  }\n\n  setUserCurrentNode(node: Node, shouldAutoExpandParent = true): void {\n    const key = node[this.key]\n    const currNode = this.nodesMap[key]\n    this.setCurrentNode(currNode)\n    if (shouldAutoExpandParent && this.currentNode.level > 1) {\n      this.currentNode.parent.expand(null, true)\n    }\n  }\n\n  setCurrentNodeKey(key: TreeKey, shouldAutoExpandParent = true): void {\n    if (key === null || key === undefined) {\n      this.currentNode && (this.currentNode.isCurrent = false)\n      this.currentNode = null\n      return\n    }\n    const node = this.getNode(key)\n    if (node) {\n      this.setCurrentNode(node)\n      if (shouldAutoExpandParent && this.currentNode.level > 1) {\n        this.currentNode.parent.expand(null, true)\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"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"}
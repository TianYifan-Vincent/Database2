{"version":3,"file":"store.mjs","sources":["../../../../../../packages/components/cascader-panel/src/store.ts"],"sourcesContent":["import isEqual from 'lodash/isEqual'\nimport Node from './node'\n\nimport type { Nullable } from '@element-plus/utils/types'\nimport type {\n  CascaderNodeValue,\n  CascaderNodePathValue,\n  CascaderOption,\n  CascaderConfig,\n} from './node'\n\nconst flatNodes = (nodes: Node[], leafOnly: boolean) => {\n  return nodes.reduce((res, node) => {\n    if (node.isLeaf) {\n      res.push(node)\n    } else {\n      !leafOnly && res.push(node)\n      res = res.concat(flatNodes(node.children, leafOnly))\n    }\n    return res\n  }, [] as Node[])\n}\n\nexport default class Store {\n  readonly nodes: Node[]\n  readonly allNodes: Node[]\n  readonly leafNodes: Node[]\n\n  constructor(data: CascaderOption[], readonly config: CascaderConfig) {\n    const nodes = (data || []).map(\n      (nodeData) => new Node(nodeData, this.config)\n    )\n    this.nodes = nodes\n    this.allNodes = flatNodes(nodes, false)\n    this.leafNodes = flatNodes(nodes, true)\n  }\n\n  getNodes() {\n    return this.nodes\n  }\n\n  getFlattedNodes(leafOnly: boolean) {\n    return leafOnly ? this.leafNodes : this.allNodes\n  }\n\n  appendNode(nodeData: CascaderOption, parentNode?: Node) {\n    const node = parentNode\n      ? parentNode.appendChild(nodeData)\n      : new Node(nodeData, this.config)\n\n    if (!parentNode) this.nodes.push(node)\n\n    this.allNodes.push(node)\n    node.isLeaf && this.leafNodes.push(node)\n  }\n\n  appendNodes(nodeDataList: CascaderOption[], parentNode: Node) {\n    nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode))\n  }\n\n  // when checkStrictly, leaf node first\n  getNodeByValue(\n    value: CascaderNodeValue | CascaderNodePathValue,\n    leafOnly = false\n  ): Nullable<Node> {\n    if (!value && value !== 0) return null\n\n    const nodes = this.getFlattedNodes(leafOnly).filter(\n      (node) => isEqual(node.value, value) || isEqual(node.pathValues, value)\n    )\n\n    return nodes[0] || null\n  }\n\n  getSameNode(node: Node): Nullable<Node> {\n    if (!node) return null\n\n    const nodes = this.getFlattedNodes(false).filter(\n      ({ value, level }) => isEqual(node.value, value) && node.level === level\n    )\n\n    return nodes[0] || null\n  }\n}\n"],"names":[],"mappings":";;;AAWA,MAAM,YAAY,CAAC,OAAe,aAAsB;AACtD,SAAO,MAAM,OAAO,CAAC,KAAK,SAAS;AACjC,QAAI,KAAK,QAAQ;AACf,UAAI,KAAK;AAAA,WACJ;AACL,OAAC,YAAY,IAAI,KAAK;AACtB,YAAM,IAAI,OAAO,UAAU,KAAK,UAAU;AAAA;AAE5C,WAAO;AAAA,KACN;AAAA;YAGsB;AAAA,EAKzB,YAAY,MAAiC,QAAwB;AAAxB;AAC3C,UAAM,QAAS,SAAQ,IAAI,IACzB,CAAC,aAAa,IAAI,KAAK,UAAU,KAAK;AAExC,SAAK,QAAQ;AACb,SAAK,WAAW,UAAU,OAAO;AACjC,SAAK,YAAY,UAAU,OAAO;AAAA;AAAA,EAGpC,WAAW;AACT,WAAO,KAAK;AAAA;AAAA,EAGd,gBAAgB,UAAmB;AACjC,WAAO,WAAW,KAAK,YAAY,KAAK;AAAA;AAAA,EAG1C,WAAW,UAA0B,YAAmB;AACtD,UAAM,OAAO,aACT,WAAW,YAAY,YACvB,IAAI,KAAK,UAAU,KAAK;AAE5B,QAAI,CAAC;AAAY,WAAK,MAAM,KAAK;AAEjC,SAAK,SAAS,KAAK;AACnB,SAAK,UAAU,KAAK,UAAU,KAAK;AAAA;AAAA,EAGrC,YAAY,cAAgC,YAAkB;AAC5D,iBAAa,QAAQ,CAAC,aAAa,KAAK,WAAW,UAAU;AAAA;AAAA,EAI/D,eACE,OACA,WAAW,OACK;AAChB,QAAI,CAAC,SAAS,UAAU;AAAG,aAAO;AAElC,UAAM,QAAQ,KAAK,gBAAgB,UAAU,OAC3C,CAAC,SAAS,QAAQ,KAAK,OAAO,UAAU,QAAQ,KAAK,YAAY;AAGnE,WAAO,MAAM,MAAM;AAAA;AAAA,EAGrB,YAAY,MAA4B;AACtC,QAAI,CAAC;AAAM,aAAO;AAElB,UAAM,QAAQ,KAAK,gBAAgB,OAAO,OACxC,CAAC,EAAE,OAAO,YAAY,QAAQ,KAAK,OAAO,UAAU,KAAK,UAAU;AAGrE,WAAO,MAAM,MAAM;AAAA;AAAA;;;;"}
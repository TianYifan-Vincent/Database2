{"version":3,"file":"messageBox.mjs","sources":["../../../../../../packages/components/message-box/src/messageBox.ts"],"sourcesContent":["import { h, watch, render } from 'vue'\nimport { hasOwn } from '@vue/shared'\nimport isServer from '@element-plus/utils/isServer'\nimport { isVNode, isString } from '@element-plus/utils/util'\nimport MessageBoxConstructor from './index.vue'\n\nimport type { ComponentPublicInstance, VNode } from 'vue'\nimport type {\n  Action,\n  Callback,\n  MessageBoxState,\n  IElMessageBox,\n  ElMessageBoxOptions,\n  MessageBoxData,\n} from './message-box.type'\n\n// component default merge props & data\n\nconst messageInstance = new Map<\n  ComponentPublicInstance<{ doClose: () => void }>, // marking doClose as function\n  {\n    options: any\n    callback: Callback\n    resolve: (res: any) => void\n    reject: (reason?: any) => void\n  }\n>()\n\nconst initInstance = (props: any, container: HTMLElement) => {\n  const vnode = h(MessageBoxConstructor, props)\n  render(vnode, container)\n  document.body.appendChild(container.firstElementChild)\n  return vnode.component\n}\n\nconst genContainer = () => {\n  return document.createElement('div')\n}\n\nconst showMessage = (options: any) => {\n  const container = genContainer()\n  // Adding destruct method.\n  // when transition leaves emitting `vanish` evt. so that we can do the clean job.\n  options.onVanish = () => {\n    // not sure if this causes mem leak, need proof to verify that.\n    // maybe calling out like 1000 msg-box then close them all.\n    render(null, container)\n    messageInstance.delete(vm) // Remove vm to avoid mem leak.\n    // here we were suppose to call document.body.removeChild(container.firstElementChild)\n    // but render(null, container) did that job for us. so that we do not call that directly\n  }\n\n  options.onAction = (action: Action) => {\n    const currentMsg = messageInstance.get(vm)\n    let resolve: Action | { value: string; action: Action }\n    if (options.showInput) {\n      resolve = { value: vm.inputValue, action }\n    } else {\n      resolve = action\n    }\n    if (options.callback) {\n      options.callback(resolve, instance.proxy)\n    } else {\n      if (action === 'cancel' || action === 'close') {\n        if (options.distinguishCancelAndClose && action !== 'cancel') {\n          currentMsg.reject('close')\n        } else {\n          currentMsg.reject('cancel')\n        }\n      } else {\n        currentMsg.resolve(resolve)\n      }\n    }\n  }\n\n  const instance = initInstance(options, container)\n\n  // This is how we use message box programmably.\n  // Maybe consider releasing a template version?\n  // get component instance like v2.\n  const vm = instance.proxy as ComponentPublicInstance<\n    {\n      visible: boolean\n      doClose: () => void\n    } & MessageBoxState\n  >\n\n  for (const prop in options) {\n    if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {\n      vm[prop as string] = options[prop]\n    }\n  }\n\n  watch(\n    () => vm.message,\n    (newVal, oldVal) => {\n      if (isVNode(newVal)) {\n        // Override slots since message is vnode type.\n        instance.slots.default = () => [newVal]\n      } else if (isVNode(oldVal) && !isVNode(newVal)) {\n        delete instance.slots.default\n      }\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  // change visibility after everything is settled\n  vm.visible = true\n  return vm\n}\n\nasync function MessageBox(options: ElMessageBoxOptions): Promise<MessageBoxData>\nfunction MessageBox(\n  options: ElMessageBoxOptions | string | VNode\n): Promise<{ value: string; action: Action } | Action> {\n  if (isServer) return\n  let callback\n  if (isString(options) || isVNode(options)) {\n    options = {\n      message: options,\n    }\n  } else {\n    callback = options.callback\n  }\n\n  return new Promise((resolve, reject) => {\n    const vm = showMessage(options)\n    // collect this vm in order to handle upcoming events.\n    messageInstance.set(vm, {\n      options,\n      callback,\n      resolve,\n      reject,\n    })\n  })\n}\n\nMessageBox.alert = (\n  message: string,\n  title: string,\n  options?: ElMessageBoxOptions\n) => {\n  if (typeof title === 'object') {\n    options = title\n    title = ''\n  } else if (title === undefined) {\n    title = ''\n  }\n\n  return MessageBox(\n    Object.assign(\n      {\n        title,\n        message,\n        type: '',\n        closeOnPressEscape: false,\n        closeOnClickModal: false,\n      },\n      options,\n      {\n        boxType: 'alert',\n      }\n    )\n  )\n}\n\nMessageBox.confirm = (\n  message: string,\n  title: string,\n  options?: ElMessageBoxOptions\n) => {\n  if (typeof title === 'object') {\n    options = title\n    title = ''\n  } else if (title === undefined) {\n    title = ''\n  }\n  return MessageBox(\n    Object.assign(\n      {\n        title,\n        message,\n        type: '',\n        showCancelButton: true,\n      },\n      options,\n      {\n        boxType: 'confirm',\n      }\n    )\n  )\n}\n\nMessageBox.prompt = (\n  message: string,\n  title: string,\n  options?: ElMessageBoxOptions\n) => {\n  if (typeof title === 'object') {\n    options = title\n    title = ''\n  } else if (title === undefined) {\n    title = ''\n  }\n  return MessageBox(\n    Object.assign(\n      {\n        title,\n        message,\n        showCancelButton: true,\n        showInput: true,\n        type: '',\n      },\n      options,\n      {\n        boxType: 'prompt',\n      }\n    )\n  )\n}\n\nMessageBox.close = () => {\n  // instance.setupInstall.doClose()\n  // instance.setupInstall.state.visible = false\n\n  messageInstance.forEach((_, vm) => {\n    vm.doClose()\n  })\n\n  messageInstance.clear()\n}\n\nexport default MessageBox as IElMessageBox\n"],"names":["MessageBoxConstructor"],"mappings":"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"}
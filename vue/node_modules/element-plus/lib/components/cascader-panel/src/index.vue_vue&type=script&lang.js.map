{"version":3,"file":"index.vue_vue&type=script&lang.js","sources":["../../../../../../packages/components/cascader-panel/src/index.vue"],"sourcesContent":["<template>\n  <div\n    :class=\"['el-cascader-panel', border && 'is-bordered']\"\n    @keydown=\"handleKeyDown\"\n  >\n    <el-cascader-menu\n      v-for=\"(menu, index) in menus\"\n      :key=\"index\"\n      :ref=\"(item) => (menuList[index] = item)\"\n      :index=\"index\"\n      :nodes=\"menu\"\n    />\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  computed,\n  defineComponent,\n  nextTick,\n  onBeforeUpdate,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  watch,\n} from 'vue'\nimport isEqual from 'lodash/isEqual'\nimport { EVENT_CODE, focusNode, getSibling } from '@element-plus/utils/aria'\nimport { UPDATE_MODEL_EVENT, CHANGE_EVENT } from '@element-plus/utils/constants'\nimport isServer from '@element-plus/utils/isServer'\nimport scrollIntoView from '@element-plus/utils/scroll-into-view'\nimport {\n  arrayFlat,\n  coerceTruthyValueToArray,\n  deduplicate,\n  isEmpty,\n} from '@element-plus/utils/util'\n\nimport ElCascaderMenu from './menu.vue'\nimport Store from './store'\nimport Node, { ExpandTrigger } from './node'\nimport { CommonProps, useCascaderConfig } from './config'\nimport { checkNode, getMenuIndex, sortByOriginalOrder } from './utils'\nimport { CASCADER_PANEL_INJECTION_KEY } from './types'\n\nimport type { PropType } from 'vue'\nimport type { Nullable } from '@element-plus/utils/types'\nimport type {\n  CascaderValue,\n  CascaderNodeValue,\n  CascaderOption,\n  RenderLabel,\n  default as CascaderNode,\n} from './node'\n\nimport type { ElCascaderPanelContext } from './types'\n\nexport default defineComponent({\n  name: 'ElCascaderPanel',\n\n  components: {\n    ElCascaderMenu,\n  },\n\n  props: {\n    ...CommonProps,\n    border: {\n      type: Boolean,\n      default: true,\n    },\n    renderLabel: Function as PropType<RenderLabel>,\n  },\n\n  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, 'close', 'expand-change'],\n\n  setup(props, { emit, slots }) {\n    let initialLoaded = true\n    // for interrupt sync check status in lazy mode\n    let manualChecked = false\n\n    const config = useCascaderConfig(props)\n\n    const store = ref<Nullable<Store>>(null)\n    const menuList = ref<any[]>([])\n    const checkedValue = ref<Nullable<CascaderValue>>(null)\n    const menus = ref<CascaderNode[][]>([])\n    const expandingNode = ref<Nullable<CascaderNode>>(null)\n    const checkedNodes = ref<CascaderNode[]>([])\n\n    const isHoverMenu = computed(\n      () => config.value.expandTrigger === ExpandTrigger.HOVER\n    )\n    const renderLabelFn = computed(() => props.renderLabel || slots.default)\n\n    const initStore = () => {\n      const { options } = props\n      const cfg = config.value\n\n      manualChecked = false\n      store.value = new Store(options, cfg)\n      menus.value = [store.value.getNodes()]\n\n      if (cfg.lazy && isEmpty(props.options)) {\n        initialLoaded = false\n        lazyLoad(undefined, () => {\n          initialLoaded = true\n          syncCheckedValue(false, true)\n        })\n      } else {\n        syncCheckedValue(false, true)\n      }\n    }\n\n    const lazyLoad: ElCascaderPanelContext['lazyLoad'] = (node, cb) => {\n      const cfg = config.value\n      node! = node || new Node({}, cfg, undefined, true)\n      node.loading = true\n\n      const resolve = (dataList: CascaderOption[]) => {\n        const _node = node as Node\n        const parent = _node.root ? null : _node\n        dataList && store.value?.appendNodes(dataList, parent as any)\n        _node.loading = false\n        _node.loaded = true\n        _node.childrenData = _node.childrenData || []\n        cb && cb(dataList)\n      }\n\n      cfg.lazyLoad(node, resolve as any)\n    }\n\n    const expandNode: ElCascaderPanelContext['expandNode'] = (node, silent) => {\n      const { level } = node\n      const newMenus = menus.value.slice(0, level)\n      let newExpandingNode: Nullable<CascaderNode>\n\n      if (node.isLeaf) {\n        newExpandingNode = node.pathNodes[level - 2]\n      } else {\n        newExpandingNode = node\n        newMenus.push(node.children)\n      }\n\n      if (expandingNode.value?.uid !== newExpandingNode?.uid) {\n        expandingNode.value = node\n        menus.value = newMenus\n        !silent && emit('expand-change', node?.pathValues || [])\n      }\n    }\n\n    const handleCheckChange: ElCascaderPanelContext['handleCheckChange'] = (\n      node,\n      checked,\n      emitClose = true\n    ) => {\n      const { checkStrictly, multiple } = config.value\n      const oldNode = checkedNodes.value[0]\n      manualChecked = true\n\n      !multiple && oldNode?.doCheck(false)\n      node.doCheck(checked)\n      calculateCheckedValue()\n      emitClose && !multiple && !checkStrictly && emit('close')\n      !emitClose && !multiple && !checkStrictly && expandParentNode(node)\n    }\n\n    const expandParentNode = (node) => {\n      if (!node) return\n      node = node.parent\n      expandParentNode(node)\n      node && expandNode(node)\n    }\n\n    const getFlattedNodes = (leafOnly: boolean) => {\n      return store.value?.getFlattedNodes(leafOnly)\n    }\n\n    const getCheckedNodes = (leafOnly: boolean) => {\n      return getFlattedNodes(leafOnly)?.filter((node) => node.checked !== false)\n    }\n\n    const clearCheckedNodes = () => {\n      checkedNodes.value.forEach((node) => node.doCheck(false))\n      calculateCheckedValue()\n    }\n\n    const calculateCheckedValue = () => {\n      const { checkStrictly, multiple } = config.value\n      const oldNodes = checkedNodes.value\n      const newNodes = getCheckedNodes(!checkStrictly)!\n      // ensure the original order\n      const nodes = sortByOriginalOrder(oldNodes, newNodes)\n      const values = nodes.map((node) => node.valueByOption)\n      checkedNodes.value = nodes\n      checkedValue.value = multiple ? values : values[0] ?? null\n    }\n\n    const syncCheckedValue = (loaded = false, forced = false) => {\n      const { modelValue } = props\n      const { lazy, multiple, checkStrictly } = config.value\n      const leafOnly = !checkStrictly\n\n      if (\n        !initialLoaded ||\n        manualChecked ||\n        (!forced && isEqual(modelValue, checkedValue.value))\n      )\n        return\n\n      if (lazy && !loaded) {\n        const values: CascaderNodeValue[] = deduplicate(\n          arrayFlat(coerceTruthyValueToArray(modelValue))\n        )\n        const nodes = values\n          .map((val) => store.value?.getNodeByValue(val))\n          .filter((node) => !!node && !node.loaded && !node.loading) as Node[]\n\n        if (nodes.length) {\n          nodes.forEach((node) => {\n            lazyLoad(node, () => syncCheckedValue(false, forced))\n          })\n        } else {\n          syncCheckedValue(true, forced)\n        }\n      } else {\n        const values = multiple\n          ? coerceTruthyValueToArray(modelValue)\n          : [modelValue]\n        const nodes = deduplicate(\n          values.map((val) => store.value?.getNodeByValue(val, leafOnly))\n        ) as Node[]\n        syncMenuState(nodes, false)\n        checkedValue.value = modelValue!\n      }\n    }\n\n    const syncMenuState = (\n      newCheckedNodes: CascaderNode[],\n      reserveExpandingState = true\n    ) => {\n      const { checkStrictly } = config.value\n      const oldNodes = checkedNodes.value\n      const newNodes = newCheckedNodes.filter(\n        (node) => !!node && (checkStrictly || node.isLeaf)\n      )\n      const oldExpandingNode = store.value?.getSameNode(expandingNode.value!)\n      const newExpandingNode =\n        (reserveExpandingState && oldExpandingNode) || newNodes[0]\n\n      if (newExpandingNode) {\n        newExpandingNode.pathNodes.forEach((node) => expandNode(node, true))\n      } else {\n        expandingNode.value = null\n      }\n\n      oldNodes.forEach((node) => node.doCheck(false))\n      newNodes.forEach((node) => node.doCheck(true))\n\n      checkedNodes.value = newNodes\n      nextTick(scrollToExpandingNode)\n    }\n\n    const scrollToExpandingNode = () => {\n      if (isServer) return\n\n      menuList.value.forEach((menu) => {\n        const menuElement = menu?.$el\n        if (menuElement) {\n          const container = menuElement.querySelector('.el-scrollbar__wrap')\n          const activeNode =\n            menuElement.querySelector('.el-cascader-node.is-active') ||\n            menuElement.querySelector('.el-cascader-node.in-active-path')\n          scrollIntoView(container, activeNode)\n        }\n      })\n    }\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const target = e.target as HTMLElement\n      const { code } = e\n\n      switch (code) {\n        case EVENT_CODE.up:\n        case EVENT_CODE.down: {\n          const distance = code === EVENT_CODE.up ? -1 : 1\n          focusNode(\n            getSibling(target, distance, '.el-cascader-node[tabindex=\"-1\"]')\n          )\n          break\n        }\n        case EVENT_CODE.left: {\n          const preMenu = menuList.value[getMenuIndex(target) - 1]\n          const expandedNode = preMenu?.$el.querySelector(\n            '.el-cascader-node[aria-expanded=\"true\"]'\n          )\n          focusNode(expandedNode)\n          break\n        }\n        case EVENT_CODE.right: {\n          const nextMenu = menuList.value[getMenuIndex(target) + 1]\n          const firstNode = nextMenu?.$el.querySelector(\n            '.el-cascader-node[tabindex=\"-1\"]'\n          )\n          focusNode(firstNode)\n          break\n        }\n        case EVENT_CODE.enter:\n          checkNode(target)\n          break\n        case EVENT_CODE.esc:\n        case EVENT_CODE.tab:\n          emit('close')\n          break\n      }\n    }\n\n    provide(\n      CASCADER_PANEL_INJECTION_KEY,\n      reactive({\n        config,\n        expandingNode,\n        checkedNodes,\n        isHoverMenu,\n        renderLabelFn,\n        lazyLoad,\n        expandNode,\n        handleCheckChange,\n      })\n    )\n\n    watch([config, () => props.options], initStore, {\n      deep: true,\n      immediate: true,\n    })\n\n    watch(\n      () => props.modelValue,\n      () => {\n        manualChecked = false\n        syncCheckedValue()\n      }\n    )\n\n    watch(checkedValue, (val) => {\n      if (!isEqual(val, props.modelValue)) {\n        emit(UPDATE_MODEL_EVENT, val)\n        emit(CHANGE_EVENT, val)\n      }\n    })\n\n    onBeforeUpdate(() => (menuList.value = []))\n\n    onMounted(() => !isEmpty(props.modelValue) && syncCheckedValue())\n\n    return {\n      menuList,\n      menus,\n      checkedNodes,\n      handleKeyDown,\n      handleCheckChange,\n      getFlattedNodes,\n      getCheckedNodes,\n      clearCheckedNodes,\n      calculateCheckedValue,\n      scrollToExpandingNode,\n    }\n  },\n})\n</script>\n"],"names":["defineComponent","ElCascaderMenu","CommonProps","UPDATE_MODEL_EVENT","CHANGE_EVENT","config","useCascaderConfig","store","ref","computed","ExpandTrigger","Store","isEmpty","node","Node","sortByOriginalOrder","isEqual","deduplicate","arrayFlat","coerceTruthyValueToArray","isServer","EVENT_CODE","getSibling","getMenuIndex","CASCADER_PANEL_INJECTION_KEY","reactive"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AA0DA,aAAeA,oBAAgB;AAAA,EAC7B,MAAM;AAAA,EAEN,YAAY;AAAA,oBACVC;AAAA;AAAA,EAGF,OAAO;AAAA,OACFC;AAAA,IACH,QAAQ;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA;AAAA,IAEX,aAAa;AAAA;AAAA,EAGf,OAAO,CAACC,8BAAoBC,wBAAc,SAAS;AAAA,EAEnD,MAAM,OAAO,EAAE,MAAM,SAAS;AAC5B,QAAI,gBAAgB;AAEpB,QAAI,gBAAgB;AAEpB,UAAMC,WAASC,yBAAkB;AAEjC,UAAMC,UAAQC,QAAqB;AACnC,UAAM,WAAWA,QAAW;AAC5B,UAAM,eAAeA,QAA6B;AAClD,UAAM,QAAQA,QAAsB;AACpC,UAAM,gBAAgBA,QAA4B;AAClD,UAAM,eAAeA,QAAoB;AAEzC,UAAM,cAAcC,aAClB,MAAMJ,SAAO,MAAM,kBAAkBK,mBAAc;AAErD,UAAM,gBAAgBD,aAAS,MAAM,MAAM,eAAe,MAAM;AAEhE,UAAM,YAAY,MAAM;AACtB,YAAM,EAAE,YAAY;AACpB,YAAM,MAAMJ,SAAO;AAEnB,sBAAgB;AAChB,cAAM,QAAQ,IAAIM,iBAAM,SAAS;AACjC,YAAM,QAAQ,CAACJ,QAAM,MAAM;AAE3B,UAAI,IAAI,QAAQK,aAAQ,MAAM,UAAU;AACtC,wBAAgB;AAChB,iBAAS,QAAW,MAAM;AACxB,0BAAgB;AAChB,2BAAiB,OAAO;AAAA;AAAA,aAErB;AACL,yBAAiB,OAAO;AAAA;AAAA;AAI5B,UAAM,WAA+C,CAACC,QAAM,OAAO;AACjE,YAAM,MAAMR,SAAO;AACnB,eAAQQ,UAAQ,IAAIC,gBAAK,IAAI,KAAK,QAAW;AAC7C,aAAK,UAAU;AAEf,YAAM,UAAU,CAAC,aAA+B;;AAC9C,cAAM,QAAQD;AACd,cAAM,SAAS,MAAM,OAAO,OAAO;AACnC,mCAAkB,UAAN,mBAAa,YAAY,UAAU;AAC/C,cAAM,UAAU;AAChB,cAAM,SAAS;AACf,cAAM,eAAe,MAAM,gBAAgB;AAC3C,cAAM,GAAG;AAAA;AAGX,UAAI,SAASA,QAAM;AAAA;AAGrB,UAAM,aAAmD,CAAC,MAAM,WAAW;;AACzE,YAAM,EAAE,UAAU;AAClB,YAAM,WAAW,MAAM,MAAM,MAAM,GAAG;AACtC,UAAI;AAEJ,UAAI,KAAK,QAAQ;AACf,2BAAmB,KAAK,UAAU,QAAQ;AAAA,aACrC;AACL,2BAAmB;AACnB,iBAAS,KAAK,KAAK;AAAA;AAGrB,UAAI,qBAAc,UAAd,mBAAqB,+DAA0B,MAAK;AACtD,sBAAc,QAAQ;AACtB,cAAM,QAAQ;AACd,SAAC,UAAU,KAAK,iBAAiB,8BAAM,eAAc;AAAA;AAAA;AAIzD,UAAM,oBAAiE,CACrE,MACA,SACA,YAAY,SACT;AACH,YAAM,EAAE,eAAe,aAAaR,SAAO;AAC3C,YAAM,UAAU,aAAa,MAAM;AACnC,sBAAgB;AAEhB,OAAC,gDAAqB,QAAQ;AAC9B,WAAK,QAAQ;AACb;AACA,mBAAa,CAAC,YAAY,CAAC,iBAAiB,KAAK;AACjD,OAAC,aAAa,CAAC,YAAY,CAAC,iBAAiB,iBAAiB;AAAA;AAGhE,UAAM,mBAAmB,CAAC,SAAS;AACjC,UAAI,CAAC;AAAM;AACX,aAAO,KAAK;AACZ,uBAAiB;AACjB,cAAQ,WAAW;AAAA;AAGrB,UAAM,kBAAkB,CAAC,aAAsB;;AAC7C,aAAO,cAAM,UAAN,mBAAa,gBAAgB;AAAA;AAGtC,UAAM,kBAAkB,CAAC,aAAsB;;AAC7C,aAAO,sBAAgB,cAAhB,mBAA2B,OAAO,CAAC,SAAS,KAAK,YAAY;AAAA;AAGtE,UAAM,oBAAoB,MAAM;AAC9B,mBAAa,MAAM,QAAQ,CAAC,SAAS,KAAK,QAAQ;AAClD;AAAA;AAGF,UAAM,wBAAwB,MAAM;;AAClC,YAAM,EAAE,eAAe,aAAaA,SAAO;AAC3C,YAAM,WAAW,aAAa;AAC9B,YAAM,WAAW,gBAAgB,CAAC;AAElC,YAAM,QAAQU,0BAAoB,UAAU;AAC5C,YAAM,SAAS,MAAM,IAAI,CAAC,SAAS,KAAK;AACxC,mBAAa,QAAQ;AACrB,mBAAa,QAAQ,WAAW,SAAS,aAAO,OAAP,YAAa;AAAA;AAGxD,UAAM,mBAAmB,CAAC,SAAS,OAAO,SAAS,UAAU;AAC3D,YAAM,EAAE,eAAe;AACvB,YAAM,EAAE,MAAM,UAAU,kBAAkBV,SAAO;AACjD,YAAM,WAAW,CAAC;AAElB,UACE,CAAC,iBACD,iBACC,CAAC,UAAUW,4BAAQ,YAAY,aAAa;AAE7C;AAEF,UAAI,QAAQ,CAAC,QAAQ;AACnB,cAAM,SAA8BC,iBAClCC,eAAUC,8BAAyB;AAErC,cAAM,QAAQ,OACX,IAAI,CAAC,QAAK;;AAAG,+BAAM,UAAN,mBAAa,eAAe;AAAA,WACzC,OAAO,CAAC,SAAS,CAAC,CAAC,QAAQ,CAAC,KAAK,UAAU,CAAC,KAAK;AAEpD,YAAI,MAAM,QAAQ;AAChB,gBAAM,QAAQ,CAAC,SAAS;AACtB,qBAAS,MAAM,MAAM,iBAAiB,OAAO;AAAA;AAAA,eAE1C;AACL,2BAAiB,MAAM;AAAA;AAAA,aAEpB;AACL,cAAM,SAAS,WACXA,8BAAyB,cACzB,CAAC;AACL,cAAM,QAAQF,iBACZ,OAAO,IAAI,CAAC,QAAK;;AAAG,+BAAM,UAAN,mBAAa,eAAe,KAAK;AAAA;AAEvD,sBAAc,OAAO;AACrB,qBAAa,QAAQ;AAAA;AAAA;AAIzB,UAAM,gBAAgB,CACpB,iBACA,wBAAwB,SACrB;;AACH,YAAM,EAAE,kBAAkBZ,SAAO;AACjC,YAAM,WAAW,aAAa;AAC9B,YAAM,WAAW,gBAAgB,OAC/B,CAAC,SAAS,CAAC,CAAC,0BAA0B,KAAK;AAE7C,YAAM,mBAAmB,cAAM,UAAN,mBAAa,YAAY,cAAc;AAChE,YAAM,mBACH,yBAAyB,oBAAqB,SAAS;AAE1D,UAAI,kBAAkB;AACpB,yBAAiB,UAAU,QAAQ,CAAC,SAAS,WAAW,MAAM;AAAA,aACzD;AACL,sBAAc,QAAQ;AAAA;AAGxB,eAAS,QAAQ,CAAC,SAAS,KAAK,QAAQ;AACxC,eAAS,QAAQ,CAAC,SAAS,KAAK,QAAQ;AAExC,mBAAa,QAAQ;AACrB,mBAAS;AAAA;AAGX,UAAM,wBAAwB,MAAM;AAClC,UAAIe;AAAU;AAEd,eAAS,MAAM,QAAQ,CAAC,SAAS;AAC/B,cAAM,cAAc,6BAAM;AAC1B,YAAI,aAAa;AACf,gBAAM,YAAY,YAAY,cAAc;AAC5C,gBAAM,aACJ,YAAY,cAAc,kCAC1B,YAAY,cAAc;AAC5B,oCAAe,WAAW;AAAA;AAAA;AAAA;AAKhC,UAAM,gBAAgB,CAAC,MAAqB;AAC1C,YAAM,SAAS,EAAE;AACjB,YAAM,EAAE,SAAS;AAEjB,cAAQ;AAAA,aACDC,gBAAW;AAAA,aACXA,gBAAW,MAAM;AACpB,gBAAM,WAAW,SAASA,gBAAW,KAAK,KAAK;AAC/C,yBACEC,gBAAW,QAAQ,UAAU;AAE/B;AAAA;AAAA,aAEGD,gBAAW,MAAM;AACpB,gBAAM,UAAU,SAAS,MAAME,mBAAa,UAAU;AACtD,gBAAM,eAAe,mCAAS,IAAI,cAChC;AAEF,yBAAU;AACV;AAAA;AAAA,aAEGF,gBAAW,OAAO;AACrB,gBAAM,WAAW,SAAS,MAAME,mBAAa,UAAU;AACvD,gBAAM,YAAY,qCAAU,IAAI,cAC9B;AAEF,yBAAU;AACV;AAAA;AAAA,aAEGF,gBAAW;AACd,0BAAU;AACV;AAAA,aACGA,gBAAW;AAAA,aACXA,gBAAW;AACd,eAAK;AACL;AAAA;AAAA;AAIN,gBACEG,oCACAC,aAAS;AAAA,cACPpB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAIJ,cAAM,CAACA,UAAQ,MAAM,MAAM,UAAU,WAAW;AAAA,MAC9C,MAAM;AAAA,MACN,WAAW;AAAA;AAGb,cACE,MAAM,MAAM,YACZ,MAAM;AACJ,sBAAgB;AAChB;AAAA;AAIJ,cAAM,cAAc,CAAC,QAAQ;AAC3B,UAAI,CAACW,4BAAQ,KAAK,MAAM,aAAa;AACnC,aAAKb,8BAAoB;AACzB,aAAKC,wBAAc;AAAA;AAAA;AAIvB,uBAAe,MAAO,SAAS,QAAQ;AAEvC,kBAAU,MAAM,CAACQ,aAAQ,MAAM,eAAe;AAE9C,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA;AAAA;;;;"}
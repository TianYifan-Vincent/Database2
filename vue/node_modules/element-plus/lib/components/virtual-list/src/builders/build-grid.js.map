{"version":3,"file":"build-grid.js","sources":["../../../../../../../packages/components/virtual-list/src/builders/build-grid.ts"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  ref,\n  nextTick,\n  onMounted,\n  onUpdated,\n  resolveDynamicComponent,\n  h,\n  unref,\n} from 'vue'\nimport { hasOwn } from '@vue/shared'\n\nimport { isNumber, isString } from '@element-plus/utils/util'\nimport isServer from '@element-plus/utils/isServer'\nimport getScrollBarWidth from '@element-plus/utils/scrollbar-width'\n\nimport Scrollbar from '../components/scrollbar'\nimport { useGridWheel } from '../hooks/use-grid-wheel'\nimport { useCache } from '../hooks/use-cache'\nimport { virtualizedGridProps } from '../props'\nimport { getScrollDir, getRTLOffsetType, isRTL } from '../utils'\nimport {\n  AUTO_ALIGNMENT,\n  BACKWARD,\n  FORWARD,\n  RTL,\n  ITEM_RENDER_EVT,\n  SCROLL_EVT,\n  RTL_OFFSET_NAG,\n  RTL_OFFSET_POS_DESC,\n  RTL_OFFSET_POS_ASC,\n} from '../defaults'\n\nimport type { CSSProperties, VNode, VNodeChild } from 'vue'\nimport type { StyleValue } from '@element-plus/utils/types'\nimport type { GridConstructorProps, Alignment, ScrollbarExpose } from '../types'\nimport type { VirtualizedGridProps } from '../props'\n\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n\n  initCache,\n  validateProps,\n}: GridConstructorProps<VirtualizedGridProps>) => {\n  return defineComponent({\n    name: name ?? 'ElVirtualList',\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose, slots }) {\n      validateProps(props)\n      const instance = getCurrentInstance()!\n      const cache = ref(initCache(props, instance))\n      // refs\n      // here windowRef and innerRef can be type of HTMLElement\n      // or user defined component type, depends on the type passed\n      // by user\n      const windowRef = ref<HTMLElement>()\n      const hScrollbar = ref<ScrollbarExpose>()\n      const vScrollbar = ref<ScrollbarExpose>()\n      // innerRef is the actual container element which contains all the elements\n      const innerRef = ref(null)\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD,\n      })\n\n      const getItemStyleCache = useCache()\n\n      // computed\n      const parsedHeight = computed(() => parseInt(`${props.height}`, 10))\n      const parsedWidth = computed(() => parseInt(`${props.width}`, 10))\n      const columnsToRender = computed(() => {\n        const { totalColumn, totalRow, columnCache } = props\n        const { isScrolling, xAxisScrollDir, scrollLeft } = unref(states)\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getColumnStartIndexForOffset(\n          props,\n          scrollLeft,\n          unref(cache)\n        )\n        const stopIndex = getColumnStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollLeft,\n          unref(cache)\n        )\n\n        const cacheBackward =\n          !isScrolling || xAxisScrollDir === BACKWARD\n            ? Math.max(1, columnCache)\n            : 1\n        const cacheForward =\n          !isScrolling || xAxisScrollDir === FORWARD\n            ? Math.max(1, columnCache)\n            : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalColumn! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const rowsToRender = computed(() => {\n        const { totalColumn, totalRow, rowCache } = props\n        const { isScrolling, yAxisScrollDir, scrollTop } = unref(states)\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getRowStartIndexForOffset(\n          props,\n          scrollTop,\n          unref(cache)\n        )\n        const stopIndex = getRowStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollTop,\n          unref(cache)\n        )\n\n        const cacheBackward =\n          !isScrolling || yAxisScrollDir === BACKWARD\n            ? Math.max(1, rowCache)\n            : 1\n        const cacheForward =\n          !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalRow! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const estimatedTotalHeight = computed(() =>\n        getEstimatedTotalHeight(props, unref(cache))\n      )\n      const estimatedTotalWidth = computed(() =>\n        getEstimatedTotalWidth(props, unref(cache))\n      )\n\n      const windowStyle = computed<StyleValue>(() => [\n        {\n          position: 'relative',\n          overflow: 'hidden',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width,\n        },\n        props.style ?? {},\n      ])\n\n      const innerStyle = computed(() => {\n        const width = `${unref(estimatedTotalWidth)}px`\n        const height = `${unref(estimatedTotalHeight)}px`\n\n        return {\n          height,\n          pointerEvents: unref(states).isScrolling ? 'none' : undefined,\n          width,\n        }\n      })\n\n      // methods\n      const emitEvents = () => {\n        const { totalColumn, totalRow } = props\n\n        if (totalColumn! > 0 && totalRow! > 0) {\n          const [\n            columnCacheStart,\n            columnCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n          ] = unref(columnsToRender)\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] =\n            unref(rowsToRender)\n          // emit the render item event with\n          // [xAxisInvisibleStart, xAxisInvisibleEnd, xAxisVisibleStart, xAxisVisibleEnd]\n          // [yAxisInvisibleStart, yAxisInvisibleEnd, yAxisVisibleStart, yAxisVisibleEnd]\n          emit(\n            ITEM_RENDER_EVT,\n            columnCacheStart,\n            columnCacheEnd,\n            rowCacheStart,\n            rowCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n            rowVisibleStart,\n            rowVisibleEnd\n          )\n        }\n\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir,\n        } = unref(states)\n        emit(\n          SCROLL_EVT,\n          xAxisScrollDir,\n          scrollLeft,\n          yAxisScrollDir,\n          scrollTop,\n          updateRequested\n        )\n      }\n\n      const onScroll = (e: Event) => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth,\n        } = e.currentTarget as HTMLElement\n\n        const _states = unref(states)\n        if (\n          _states.scrollTop === scrollTop &&\n          _states.scrollLeft === scrollLeft\n        ) {\n          return\n        }\n\n        let _scrollLeft = scrollLeft\n\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft\n              break\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft\n              break\n          }\n        }\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(\n            0,\n            Math.min(scrollTop, scrollHeight - clientHeight)\n          ),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n        }\n\n        nextTick(resetIsScrolling)\n\n        emitEvents()\n      }\n\n      const onVerticalScroll = (distance: number, totalSteps: number) => {\n        const height = unref(parsedHeight)\n        const offset =\n          ((estimatedTotalHeight.value - height) / totalSteps) * distance\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset),\n        })\n      }\n\n      const onHorizontalScroll = (distance: number, totalSteps: number) => {\n        const width = unref(parsedWidth)\n        const offset =\n          ((estimatedTotalWidth.value - width) / totalSteps) * distance\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset),\n        })\n      }\n\n      const { onWheel } = useGridWheel(\n        {\n          atXStartEdge: computed(() => states.value.scrollLeft <= 0),\n          atXEndEdge: computed(\n            () => states.value.scrollLeft >= estimatedTotalWidth.value\n          ),\n          atYStartEdge: computed(() => states.value.scrollTop <= 0),\n          atYEndEdge: computed(\n            () => states.value.scrollTop >= estimatedTotalHeight.value\n          ),\n        },\n        (x: number, y: number) => {\n          hScrollbar.value?.onMouseUp?.()\n          hScrollbar.value?.onMouseUp?.()\n          const width = unref(parsedWidth)\n          const height = unref(parsedHeight)\n          scrollTo({\n            scrollLeft: Math.min(\n              states.value.scrollLeft + x,\n              estimatedTotalWidth.value - width\n            ),\n            scrollTop: Math.min(\n              states.value.scrollTop + y,\n              estimatedTotalHeight.value - height\n            ),\n          })\n        }\n      )\n\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop,\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0)\n        scrollTop = Math.max(scrollTop, 0)\n        const _states = unref(states)\n        if (\n          scrollTop === _states.scrollTop &&\n          scrollLeft === _states.scrollLeft\n        ) {\n          return\n        }\n\n        states.value = {\n          ..._states,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollToItem = (\n        rowIndex = 0,\n        columnIdx = 0,\n        alignment: Alignment = AUTO_ALIGNMENT\n      ) => {\n        const _states = unref(states)\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn! - 1))\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow! - 1))\n        const scrollBarWidth = getScrollBarWidth()\n\n        const _cache = unref(cache)\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache)\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache)\n\n        scrollTo({\n          scrollLeft: getColumnOffset(\n            props,\n            columnIdx,\n            alignment,\n            _states.scrollLeft,\n            _cache,\n            estimatedWidth > props.width! ? scrollBarWidth : 0\n          ),\n          scrollTop: getRowOffset(\n            props,\n            rowIndex,\n            alignment,\n            _states.scrollTop,\n            _cache,\n            estimatedHeight > props.height! ? scrollBarWidth : 0\n          ),\n        })\n      }\n\n      const getItemStyle = (\n        rowIndex: number,\n        columnIndex: number\n      ): CSSProperties => {\n        const { columnWidth, direction, rowHeight } = props\n\n        const itemStyleCache = getItemStyleCache.value(\n          clearCache && columnWidth,\n          clearCache && rowHeight,\n          clearCache && direction\n        )\n        // since there was no need to introduce an nested array into cache object\n        // we use row,column to construct the key for indexing the map.\n        const key = `${rowIndex},${columnIndex}`\n\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key]\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, unref(cache))\n          const _cache = unref(cache)\n\n          const rtl = isRTL(direction)\n          const [height, top] = getRowPosition(props, rowIndex, _cache)\n          const [width] = getColumnPosition(props, columnIndex, _cache)\n\n          itemStyleCache[key] = {\n            position: 'absolute',\n            left: rtl ? undefined : `${left}px`,\n            right: rtl ? `${left}px` : undefined,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`,\n          }\n\n          return itemStyleCache[key]\n        }\n      }\n\n      // TODO: debounce setting is scrolling.\n\n      const resetIsScrolling = () => {\n        // timer = null\n\n        states.value.isScrolling = false\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null)\n        })\n      }\n\n      // life cycles\n      onMounted(() => {\n        // for SSR\n        if (isServer) return\n        const { initScrollLeft, initScrollTop } = props\n        const windowElement = unref(windowRef)\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop\n          }\n        }\n        emitEvents()\n      })\n\n      onUpdated(() => {\n        const { direction } = props\n        const { scrollLeft, scrollTop, updateRequested } = unref(states)\n\n        const windowElement = unref(windowRef)\n\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG: {\n                windowElement.scrollLeft = -scrollLeft\n                break\n              }\n              case RTL_OFFSET_POS_ASC: {\n                windowElement.scrollLeft = scrollLeft\n                break\n              }\n              default: {\n                const { clientWidth, scrollWidth } = windowElement\n                windowElement.scrollLeft =\n                  scrollWidth - clientWidth - scrollLeft\n                break\n              }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft)\n          }\n\n          windowElement.scrollTop = Math.max(0, scrollTop)\n        }\n      })\n\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states,\n      })\n\n      // rendering part\n\n      const renderScrollbars = () => {\n        const { totalColumn, totalRow } = props\n\n        const width = unref(parsedWidth)\n        const height = unref(parsedHeight)\n        const estimatedWidth = unref(estimatedTotalWidth)\n        const estimatedHeight = unref(estimatedTotalHeight)\n        const { scrollLeft, scrollTop } = unref(states)\n        const horizontalScrollbar = h(Scrollbar, {\n          ref: hScrollbar,\n          clientSize: width,\n          layout: 'horizontal',\n          onScroll: onHorizontalScroll,\n          ratio: (width * 100) / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true,\n        })\n\n        const verticalScrollbar = h(Scrollbar, {\n          ref: vScrollbar,\n          clientSize: height,\n          layout: 'vertical',\n          onScroll: onVerticalScroll,\n          ratio: (height * 100) / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true,\n        })\n\n        return {\n          horizontalScrollbar,\n          verticalScrollbar,\n        }\n      }\n\n      const renderItems = () => {\n        const [columnStart, columnEnd] = unref(columnsToRender)\n        const [rowStart, rowEnd] = unref(rowsToRender)\n        const { data, totalColumn, totalRow, useIsScrolling } = props\n        const children: VNodeChild[] = []\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              children.push(\n                slots.default?.({\n                  columnIndex: column,\n                  data,\n                  key: column,\n                  isScrolling: useIsScrolling\n                    ? unref(states).isScrolling\n                    : undefined,\n                  style: getItemStyle(row, column),\n                  rowIndex: row,\n                })\n              )\n            }\n          }\n        }\n        return children\n      }\n\n      const renderInner = () => {\n        const Inner = resolveDynamicComponent(props.innerElement) as VNode\n        const children = renderItems()\n        return [\n          h(\n            Inner,\n            {\n              style: unref(innerStyle),\n              ref: innerRef,\n            },\n            !isString(Inner)\n              ? {\n                  default: () => children,\n                }\n              : children\n          ),\n        ]\n      }\n\n      const renderWindow = () => {\n        const Container = resolveDynamicComponent(\n          props.containerElement\n        ) as VNode\n        const { horizontalScrollbar, verticalScrollbar } = renderScrollbars()\n        const Inner = renderInner()\n\n        return h(\n          'div',\n          {\n            key: 0,\n            class: 'el-vg__wrapper',\n          },\n          [\n            h(\n              Container,\n              {\n                class: props.className,\n                style: unref(windowStyle),\n                onScroll,\n                onWheel,\n                ref: windowRef,\n              },\n              !isString(Container) ? { default: () => Inner } : Inner\n            ),\n            horizontalScrollbar,\n            verticalScrollbar,\n          ]\n        )\n      }\n\n      return renderWindow\n    },\n  })\n}\nexport default createGrid\n"],"names":["defineComponent","virtualizedGridProps","ITEM_RENDER_EVT","SCROLL_EVT","getCurrentInstance","ref","isNumber","FORWARD","useCache","computed","unref","BACKWARD","isRTL","getRTLOffsetType","RTL_OFFSET_NAG","RTL_OFFSET_POS_DESC","getScrollDir","useGridWheel","AUTO_ALIGNMENT","getScrollBarWidth","hasOwn","isServer","RTL","RTL_OFFSET_POS_ASC","h","Scrollbar","resolveDynamicComponent","isString"],"mappings":"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"}
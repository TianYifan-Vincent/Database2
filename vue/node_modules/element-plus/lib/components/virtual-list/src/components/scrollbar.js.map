{"version":3,"file":"scrollbar.js","sources":["../../../../../../../packages/components/virtual-list/src/components/scrollbar.ts"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  ref,\n  reactive,\n  onMounted,\n  onBeforeUnmount,\n  watch,\n  h,\n  withModifiers,\n  unref,\n} from 'vue'\nimport { BAR_MAP } from '@element-plus/components/scrollbar'\nimport { on, off } from '@element-plus/utils/dom'\nimport { rAF, cAF } from '@element-plus/utils/raf'\nimport isServer from '@element-plus/utils/isServer'\n\nimport { SCROLLBAR_MIN_SIZE, HORIZONTAL, ScrollbarDirKey } from '../defaults'\nimport { virtualizedScrollbarProps } from '../props'\nimport { renderThumbStyle } from '../utils'\n\nimport type { CSSProperties } from 'vue'\n\nconst ScrollBar = defineComponent({\n  name: 'ElVirtualScrollBar',\n  props: virtualizedScrollbarProps,\n  emits: ['scroll', 'start-move', 'stop-move'],\n  setup(props, { emit }) {\n    const GAP = 4 // top 2 + bottom 2 | left 2 + right 2\n\n    // DOM refs\n    const trackRef = ref<HTMLElement>()\n    const thumbRef = ref<HTMLElement>()\n\n    // local variables\n    let frameHandle: null | number = null\n    let onselectstartStore: null | typeof document.onselectstart = null\n\n    // data\n    const state = reactive({\n      isDragging: false,\n      traveled: 0,\n    })\n\n    const bar = computed(() => BAR_MAP[props.layout])\n\n    const trackSize = computed(() => props.clientSize! - GAP)\n\n    const trackStyle = computed<CSSProperties>(() => ({\n      position: 'absolute',\n      width: HORIZONTAL === props.layout ? `${trackSize.value}px` : '6px',\n      height: HORIZONTAL === props.layout ? '6px' : `${trackSize.value}px`,\n      [ScrollbarDirKey[props.layout]]: '2px',\n      right: '2px',\n      bottom: '2px',\n      borderRadius: '4px',\n    }))\n\n    const thumbSize = computed(() => {\n      const ratio = props.ratio!\n      const clientSize = props.clientSize!\n      if (ratio >= 100) {\n        return Number.POSITIVE_INFINITY\n      }\n\n      if (ratio >= 50) {\n        return (ratio * clientSize) / 100\n      }\n\n      const SCROLLBAR_MAX_SIZE = clientSize / 3\n      return Math.floor(\n        Math.min(\n          Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE),\n          SCROLLBAR_MAX_SIZE\n        )\n      )\n    })\n\n    // const sizeRange = computed(() => props.size - thumbSize.value)\n\n    const thumbStyle = computed<CSSProperties>(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: 'none',\n        }\n      }\n\n      const thumb = `${thumbSize.value}px`\n\n      const style: CSSProperties = renderThumbStyle(\n        {\n          bar: bar.value,\n          size: thumb,\n          move: state.traveled,\n        },\n        props.layout\n      )\n\n      return style\n    })\n\n    const totalSteps = computed(() =>\n      Math.floor(props.clientSize! - thumbSize.value - GAP)\n    )\n\n    const attachEvents = () => {\n      on(window, 'mousemove', onMouseMove)\n      on(window, 'mouseup', onMouseUp)\n\n      const thumbEl = unref(thumbRef)\n\n      if (!thumbEl) return\n\n      onselectstartStore = document.onselectstart\n      document.onselectstart = () => false\n\n      on(thumbEl, 'touchmove', onMouseMove)\n      on(thumbEl, 'touchend', onMouseUp)\n    }\n\n    const detachEvents = () => {\n      off(window, 'mousemove', onMouseMove)\n      off(window, 'mouseup', onMouseUp)\n\n      document.onselectstart = onselectstartStore\n      onselectstartStore = null\n\n      const thumbEl = unref(thumbRef)\n      if (!thumbEl) return\n\n      off(thumbEl, 'touchmove', onMouseMove)\n      off(thumbEl, 'touchend', onMouseUp)\n    }\n\n    const onThumbMouseDown = (e: Event) => {\n      e.stopImmediatePropagation()\n      if (\n        (e as KeyboardEvent).ctrlKey ||\n        [1, 2].includes((e as MouseEvent).button)\n      ) {\n        return\n      }\n\n      state.isDragging = true\n      state[bar.value.axis] =\n        e.currentTarget![bar.value.offset] -\n        (e[bar.value.client] -\n          (e.currentTarget as HTMLElement).getBoundingClientRect()[\n            bar.value.direction\n          ])\n\n      emit('start-move')\n      attachEvents()\n    }\n\n    const onMouseUp = () => {\n      state.isDragging = false\n      state[bar.value.axis] = 0\n      emit('stop-move')\n      detachEvents()\n    }\n\n    const onMouseMove = (e: Event) => {\n      const { isDragging } = state\n      if (!isDragging) return\n      if (!thumbRef.value || !trackRef.value) return\n\n      const prevPage = state[bar.value.axis]\n      if (!prevPage) return\n\n      cAF(frameHandle!)\n      // using the current track's offset top/left - the current pointer's clientY/clientX\n      // to get the relative position of the pointer to the track.\n      const offset =\n        (trackRef.value.getBoundingClientRect()[bar.value.direction] -\n          e[bar.value.client]) *\n        -1\n\n      // find where the thumb was clicked on.\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage\n      /**\n       *  +--------------+                                   +--------------+\n       *  |              -  <--------- thumb.offsetTop       |              |\n       *  |             |+|             <--+                 |              |\n       *  |              -                 |                 |              |\n       *  |   Content    |                 |                 |              |\n       *  |              |                 |                 |              |\n       *  |              |                 |                 |              |\n       *  |              |                 |                 |              -\n       *  |              |                 +-->              |             |+|\n       *  |              |                                   |              -\n       *  +--------------+                                   +--------------+\n       */\n\n      // using the current position - prev position to\n\n      const distance = offset - thumbClickPosition\n      // get how many steps in total.\n      // gap of 2 on top, 2 on bottom, in total 4.\n      // using totalSteps รท totalSize getting each step's size * distance to get the new\n      // scroll offset to scrollTo\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(\n          0,\n          Math.min(\n            distance,\n            totalSteps.value // 2 is the top value\n          )\n        )\n        emit('scroll', distance, totalSteps.value)\n      })\n    }\n\n    const clickTrackHandler = (e: MouseEvent) => {\n      const offset = Math.abs(\n        (e.target as HTMLElement).getBoundingClientRect()[bar.value.direction] -\n          e[bar.value.client]\n      )\n      const thumbHalf = thumbRef.value![bar.value.offset] / 2\n      const distance = offset - thumbHalf\n\n      state.traveled = Math.max(0, Math.min(distance, totalSteps.value))\n      emit('scroll', distance, totalSteps.value)\n    }\n\n    const onScrollbarTouchStart = (e: Event) => e.preventDefault()\n\n    watch(\n      () => props.scrollFrom,\n      (v) => {\n        if (state.isDragging) return\n        /**\n         *  this is simply mapping the current scrollbar offset\n         *\n         *  formula 1:\n         *    v = scrollOffset / (estimatedTotalSize - clientSize)\n         *    traveled = v * (clientSize - thumbSize - GAP) --> v * totalSteps\n         *\n         *  formula 2:\n         *    traveled = (v * clientSize) / (clientSize / totalSteps) --> (v * clientSize) * (totalSteps / clientSize) --> v * totalSteps\n         */\n        state.traveled = Math.ceil(v! * totalSteps.value)\n      }\n    )\n\n    onMounted(() => {\n      if (isServer) return\n\n      on(trackRef.value!, 'touchstart', onScrollbarTouchStart)\n      on(thumbRef.value!, 'touchstart', onThumbMouseDown)\n    })\n\n    onBeforeUnmount(() => {\n      off(trackRef.value!, 'touchstart', onScrollbarTouchStart)\n      detachEvents()\n    })\n\n    return () => {\n      return h(\n        'div',\n        {\n          role: 'presentation',\n          ref: trackRef,\n          class: 'el-virtual-scrollbar',\n          style: trackStyle.value,\n          onMousedown: withModifiers(clickTrackHandler, ['stop', 'prevent']),\n        },\n        h(\n          'div',\n          {\n            ref: thumbRef,\n            class: 'el-scrollbar__thumb',\n            style: thumbStyle.value,\n            onMousedown: onThumbMouseDown,\n          },\n          []\n        )\n      )\n    }\n  },\n})\n\nexport default ScrollBar\n"],"names":["defineComponent","virtualizedScrollbarProps","ref","reactive","computed","BAR_MAP","HORIZONTAL","ScrollbarDirKey","SCROLLBAR_MIN_SIZE","renderThumbStyle","unref","rAF","isServer","h","withModifiers"],"mappings":"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"}
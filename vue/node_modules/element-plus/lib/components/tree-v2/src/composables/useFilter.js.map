{"version":3,"file":"useFilter.js","sources":["../../../../../../../packages/components/tree-v2/src/composables/useFilter.ts"],"sourcesContent":["import { computed, ref } from 'vue'\nimport { isFunction } from '@vue/shared'\nimport type { Ref } from 'vue'\nimport type { TreeProps, TreeKey, TreeNode, Tree } from '../types'\n\n// When the data volume is very large using filter will cause lag\n// I haven't found a better way to optimize it for now\n// Maybe this problem should be left to the server side\nexport function useFilter(props: TreeProps, tree: Ref<Tree | undefined>) {\n  const hiddenNodeKeySet = ref<Set<TreeKey>>(new Set([]))\n  const hiddenExpandIconKeySet = ref<Set<TreeKey>>(new Set([]))\n\n  const filterable = computed(() => {\n    return isFunction(props.filterMethod)\n  })\n\n  function doFilter(query: string) {\n    if (!filterable.value) {\n      return\n    }\n    const expandKeySet = new Set<TreeKey>()\n    const hiddenExpandIconKeys = hiddenExpandIconKeySet.value\n    const hiddenKeys = hiddenNodeKeySet.value\n    const family: TreeNode[] = []\n    const nodes = tree.value?.treeNodes || []\n    const filter = props.filterMethod\n    hiddenKeys.clear()\n    function traverse(nodes: TreeNode[]) {\n      nodes.forEach((node) => {\n        family.push(node)\n        if (filter?.(query, node.data)) {\n          family.forEach((member) => {\n            expandKeySet.add(member.key)\n          })\n        } else if (node.isLeaf) {\n          hiddenKeys.add(node.key)\n        }\n        const children = node.children\n        if (children) {\n          traverse(children)\n        }\n        if (!node.isLeaf) {\n          if (!expandKeySet.has(node.key)) {\n            hiddenKeys.add(node.key)\n          } else if (children) {\n            // If all child nodes are hidden, then the expand icon will be hidden\n            let allHidden = true\n            for (let i = 0; i < children.length; ++i) {\n              const childNode = children[i]\n              if (!hiddenKeys.has(childNode.key)) {\n                allHidden = false\n                break\n              }\n            }\n            if (allHidden) {\n              hiddenExpandIconKeys.add(node.key)\n            } else {\n              hiddenExpandIconKeys.delete(node.key)\n            }\n          }\n        }\n        family.pop()\n      })\n    }\n    traverse(nodes)\n    return expandKeySet\n  }\n\n  function isForceHiddenExpandIcon(node: TreeNode): boolean {\n    return hiddenExpandIconKeySet.value.has(node.key)\n  }\n\n  return {\n    hiddenExpandIconKeySet,\n    hiddenNodeKeySet,\n    doFilter,\n    isForceHiddenExpandIcon,\n  }\n}\n"],"names":["ref","computed","isFunction"],"mappings":";;;;;;;mBAQ0B,OAAkB,MAA6B;AACvE,QAAM,mBAAmBA,QAAkB,IAAI,IAAI;AACnD,QAAM,yBAAyBA,QAAkB,IAAI,IAAI;AAEzD,QAAM,aAAaC,aAAS,MAAM;AAChC,WAAOC,kBAAW,MAAM;AAAA;AAG1B,oBAAkB,OAAe;AAhBnC;AAiBI,QAAI,CAAC,WAAW,OAAO;AACrB;AAAA;AAEF,UAAM,eAAe,IAAI;AACzB,UAAM,uBAAuB,uBAAuB;AACpD,UAAM,aAAa,iBAAiB;AACpC,UAAM,SAAqB;AAC3B,UAAM,QAAQ,YAAK,UAAL,mBAAY,cAAa;AACvC,UAAM,SAAS,MAAM;AACrB,eAAW;AACX,sBAAkB,QAAmB;AACnC,aAAM,QAAQ,CAAC,SAAS;AACtB,eAAO,KAAK;AACZ,YAAI,iCAAS,OAAO,KAAK,OAAO;AAC9B,iBAAO,QAAQ,CAAC,WAAW;AACzB,yBAAa,IAAI,OAAO;AAAA;AAAA,mBAEjB,KAAK,QAAQ;AACtB,qBAAW,IAAI,KAAK;AAAA;AAEtB,cAAM,WAAW,KAAK;AACtB,YAAI,UAAU;AACZ,mBAAS;AAAA;AAEX,YAAI,CAAC,KAAK,QAAQ;AAChB,cAAI,CAAC,aAAa,IAAI,KAAK,MAAM;AAC/B,uBAAW,IAAI,KAAK;AAAA,qBACX,UAAU;AAEnB,gBAAI,YAAY;AAChB,qBAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,EAAE,GAAG;AACxC,oBAAM,YAAY,SAAS;AAC3B,kBAAI,CAAC,WAAW,IAAI,UAAU,MAAM;AAClC,4BAAY;AACZ;AAAA;AAAA;AAGJ,gBAAI,WAAW;AACb,mCAAqB,IAAI,KAAK;AAAA,mBACzB;AACL,mCAAqB,OAAO,KAAK;AAAA;AAAA;AAAA;AAIvC,eAAO;AAAA;AAAA;AAGX,aAAS;AACT,WAAO;AAAA;AAGT,mCAAiC,MAAyB;AACxD,WAAO,uBAAuB,MAAM,IAAI,KAAK;AAAA;AAG/C,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;;;;"}